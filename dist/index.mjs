import*as i from'react';var u=(e,n)=>Number.isNaN(e)&&Number.isNaN(n)?true:e===n,h=0;function m(){let e=i.useRef([]),n=i.useRef({matchedIndex:-1,value:null,comparator:u,isInMatchMode:false}),s=i.useCallback(()=>(e.current=[],n.current={matchedIndex:-1,value:null,comparator:u,isInMatchMode:false},c),[]),d=i.useCallback((o,t)=>{let a=e.current[e.current.length-1];return a?o==="when"&&a.type!=="when"?(console.warn(`[useCondition] ${t} should follow 'when()' but found '${a.type}'.`),false):o==="case"&&a.type!=="match"?(console.warn(`[useCondition] ${t} should follow 'case()' but found '${a.type}'.`),false):true:(console.warn(`[useCondition] ${t} called without a preceding condition. Use 'when()' or 'case()' first.`),false)},[]),c=i.useMemo(()=>({when(o){try{typeof o!="boolean"&&console.warn("[useCondition] when() expects a boolean value. Non-boolean values will be converted using Boolean()."),e.current.push({type:"when",condition:!!o,component:null,id:`when-${++h}`});}catch(t){console.error("[useCondition] Error during condition evaluation:",t);}return c},then(o){if(!d("when","then()"))return c;let t=e.current[e.current.length-1];return t&&(t.component!==null&&console.warn("[useCondition] Multiple then() calls detected. Only the last one will be used."),t.component=o),c},match(o,t=u){return n.current.isInMatchMode&&console.warn("[useCondition] Multiple match() calls detected. Previous match context will be overridden."),typeof t!="function"&&(console.warn("[useCondition] comparator must be a function. Using default comparator."),t=u),n.current.value=o,n.current.comparator=t,n.current.isInMatchMode=true,c},case(o){try{if(!n.current.isInMatchMode)return console.warn("[useCondition] case() called without match(). Use match() first to set the value to compare against."),c;let t=n.current.value,a=n.current.comparator,r=!1;try{r=a(t,o);}catch(l){console.error("[useCondition] Comparator function threw an error:",l),r=!1;}e.current.push({type:"match",condition:r,matchValue:o,component:null,id:`case-${++h}`});}catch(t){console.error("[useCondition] Error during condition evaluation:",t);}return c},render(o){if(!d("case","render()"))return c;let t=e.current[e.current.length-1];return t&&(t.component!==null&&console.warn("[useCondition] Multiple render() calls detected. Only the last one will be used."),t.component=o),c},fallback(o){let t=e.current.find(a=>a.type==="fallback");return t?(console.warn("[useCondition] Multiple fallback() calls detected. Only the last one will be used."),t.component=o):e.current.push({type:"fallback",component:o,id:`fallback-${++h}`}),c},debug(){return console.group("[useCondition] Debug Info"),console.log("Conditions:",e.current),console.log("Meta:",n.current),console.log("Matched Index:",n.current.matchedIndex),console.groupEnd(),c},reset:s,getMatchedIndex(){return n.current.matchedIndex},hasMatched(){return n.current.matchedIndex!==-1},getConditions(){return Object.freeze([...e.current])},otherwise(o=null){try{n.current.matchedIndex=-1;let t=e.current.filter(r=>(r.type==="when"||r.type==="match")&&r.component===null);t.length>0&&console.warn(`[useCondition] Found ${t.length} incomplete condition(s). These will be ignored.`);for(let r=0;r<e.current.length;r++){let l=e.current[r];if(l&&(l.type==="when"||l.type==="match")&&l.condition&&l.component!==null)return n.current.matchedIndex=r,l.component}let a=e.current.find(r=>r.type==="fallback");return a&&a.component!==null?a.component:o}catch(t){return console.error("[useCondition] Error during condition evaluation:",t),o}}}),[d,s]);return c}var p={strict:(e,n)=>e===n,loose:(e,n)=>e==n,deepEqual:(e,n)=>JSON.stringify(e)===JSON.stringify(n),regex:(e,n)=>n.test(e),includes:(e,n)=>Array.isArray(e)&&e.includes(n),greaterThan:(e,n)=>e>n,lessThan:(e,n)=>e<n,range:(e,n,s)=>e>=n&&e<=s},f=e=>e==null||typeof e=="string"||typeof e=="number"||typeof e=="boolean"||i.isValidElement(e)||Array.isArray(e);export{p as comparators,f as isValidReactNode,m as useCondition};//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map